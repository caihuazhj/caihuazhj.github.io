<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JAVA多线程之volatile关键字</title>
      <link href="/2018/08/26/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/08/26/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bvolatile%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>通过对synchronized的学习，我们可以发现它是一个重量级的锁，对系统性能有较大的影响。</p><p>volatile关键字是Java中提供的另一种解决可见性和有序性问题的方案。而对于原子性，需要强调一点，也是大家容易误解的一点：对volatile变量的单次读/写操作可以保证原子性的，如long和double类型变量，但是并不能保证i++这种操作的原子性，因为本质上i++是读、写两次操作。</p><p>在JAVA内存模型是围绕着在并发过程中如何处理<strong>原子性、可见性和有序性</strong>三个特征来建立的，分析volatile原理我们可以从这三个方向出发。<br><a id="more"></a></p><p>参考博客</p><p> <a href="http://www.cnblogs.com/paddix/p/5428507.html" target="_blank" rel="noopener"> Java 并发编程：volatile的使用及其原理 </a>     </p><p> <a href="http://www.cnblogs.com/Mainz/p/3556430.html#" target="_blank" rel="noopener">为什么volatile不能保证原子性而Atomic可以？</a></p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p> volatile无法保证原子性，这要从内存屏障说起。<br>详细内容请参考 <a href="http://www.cnblogs.com/Mainz/p/3556430.html#" target="_blank" rel="noopener">为什么volatile不能保证原子性而Atomic可以？</a></p><h5 id="浓缩如下："><a href="#浓缩如下：" class="headerlink" title="浓缩如下："></a>浓缩如下：</h5><p>内存屏障，也叫做内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制。</p><p>下面是完成上述规则所要求的内存屏障：</p><p><img src="/2018/08/26/JAVA多线程之volatile关键字/内存屏障.png" alt="内存屏障"></p><p><strong>从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。也就失去了原子性。</strong></p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p>（1） 修改volatile变量时会强制将修改后的值刷新的主内存中。</p><p>（2） 修改volatile变量后会导致其他线程工作内存中对应的变量值失效。因此，再读取该变量值的时候就需要重新从读取主内存中的值。</p><blockquote><p>从操作系统的层面来讲：<br>对于使用volatile修饰的操作，<strong>加入volatile关键字所生成的汇编代码会多出一个LOCK前缀指令</strong>。</p><p>LOCK# 信号确保在声言该信号期间，处理器可以独占使用任何共享内存。</p><p>同时，Lock前缀指令会引起处理器缓存回写到内存，从而使其它处理器缓存无效。</p></blockquote><h3 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h3><p>关于有序性，我们需要了解一下JAVA happens-before原则。</p><ul><li>同一个线程中的，前面的操作 happen-before 后续的操作。（即单线程内按代码顺序执行。但是，在不影响在单线程环境执行结果的前提下，编译器和处理器可以进行重排序，这是合法的。换句话说，这一是规则无法保证编译重排和指令重排）。</li><li>监视器上的解锁操作 happen-before 其后续的加锁操作。（Synchronized 规则）</li><li><strong>对volatile变量的写操作 happen-before 后续的读操作。（volatile 规则）</strong></li><li>线程的start() 方法 happen-before 该线程所有的后续操作。（线程启动规则）</li><li>线程所有的操作 happen-before 其他线程在该线程上调用 join 返回成功后的操作。</li><li>如果 a happen-before b，b happen-before c，则a happen-before c（传递性）。</li></ul><p>上述的第三条就是针对volatile描述的。</p><p>为了提高性能，编译器和处理器可能会对指令做重排序。但在多线程的条件下，重排序后的语句就会出现问题。</p><p>为了实现volatile内存语义，JMM会对volatile变量限制重排序。JVM底层是使用<strong>内存屏障</strong>来实现的。</p><p>　　</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，volatile是并发编程中的一种优化，在某些场景下可以代替Synchronized。但是，volatile的不能完全取代Synchronized的位置，只有在一些特殊的场景下，才能适用volatile。总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全：</p><p>　　（1）对变量的写操作不依赖于当前值。</p><p>　　（2）该变量没有包含在具有其他变量的不变式中。</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> volatile </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA多线程之synchronized关键字</title>
      <link href="/2018/08/26/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/08/26/JAVA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8Bsynchronized%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>提到JAVA线程安全，首先想到的肯定是synchronized关键字，但是仅仅将代码用synchronized修饰起来，仍然会出现很多问题。并且性能也会很差。虽然在JDK1.6之后，JAVA将代码进行了优化，但是相关原理也仍是有学习的必要的。</p><p>在面试当中，synchronized，volatile，lock也是经常会被提及，这篇博客首先总结一下synchronized。</p><p>参考书籍 《深入理解JAVA虚拟机》   第13章 线程安全与锁优化</p><a id="more"></a><p>参考博客 <a href="http://blog.csdn.net/javazejian/article/details/72828483" title="深入理解Java并发之synchronized实现原理" target="_blank" rel="noopener">http://blog.csdn.net/javazejian/article/details/72828483 </a></p><h2 id="应用方式"><a href="#应用方式" class="headerlink" title="应用方式"></a>应用方式</h2><p>synchronized关键字最主要有以下3种应用方式</p><ul><li><p>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁</p></li><li><p>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁</p></li><li><p>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</p></li></ul><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>Java 虚拟机中的同步(Synchronization)基于进入和退出管程(Monitor)对象实现。<br>代码块级的同步通过monitorenter 和 monitorexit 指令来实现。<br>方法级的同步通过由方法调用指令读取运行时常量池中方法的 ACC_SYNCHRONIZED 标志来隐式实现的。</p><h3 id="JAVA对象头与Monitor"><a href="#JAVA对象头与Monitor" class="headerlink" title="JAVA对象头与Monitor"></a>JAVA对象头与Monitor</h3><p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例数据和对齐填充。</p><p>一般而言，synchronized使用的锁对象是存储在Java对象头里的，其中Mark Word可以存储与锁相关额信息。重量级锁也就是通常说synchronized的对象锁，锁标识位为10，其中指针指向的是monitor对象的起始地址。</p><p>每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式。这里不再去深究monitor的数据结构。</p><h3 id="代码块级同步"><a href="#代码块级同步" class="headerlink" title="代码块级同步"></a>代码块级同步</h3><p>通过反编译得到的字节码我们可以看出，，synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。</p><p>如果Java程序中的synchronized明确指定了对象参数，那就是这个对象的reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。（<em>也就是上文提到的实例方法和静态方法的区别</em>）</p><p>根据虚拟机规范的要求，在执行monitorenter指令时，首先要尝试获取对象的锁。 如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行monitorexit指令时会将锁计数器减1，当计数器为0时，锁就被释放。 </p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到对象锁被另外一个线程释放为止。</p><h3 id="方法级同步"><a href="#方法级同步" class="headerlink" title="方法级同步"></a>方法级同步</h3><p>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。</p><p>JVM可以从方法常量池中的方法表结构(method_info Structure) 中的 ACC_SYNCHRONIZED 访问标志区分一个方法是否同步方法。</p><p>当方法调用时，调用指令将会 检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先持有monitor（虚拟机规范中用的是管程一词）， 然后再执行方法，最后再方法完成(无论是正常完成还是非正常完成)时释放monitor。</p><p>在方法执行期间，执行线程持有了monitor，其他任何线程都无法再获得同一个monitor。</p><h2 id="sychronezied的注意事项"><a href="#sychronezied的注意事项" class="headerlink" title="sychronezied的注意事项"></a>sychronezied的注意事项</h2><h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>Java的线程是映射到操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间。所以synchronized是重量级锁，在JDK1.6之后，对他做了很多优化。</p><h3 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h3><p>从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功。而synchronized是具备可重入性的。</p><h2 id="JDK-1-6以后的优化"><a href="#JDK-1-6以后的优化" class="headerlink" title="JDK    1.6以后的优化"></a>JDK    1.6以后的优化</h2><p><em>To Be Continued…</em></p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> synchronized </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Http学习之Http简介</title>
      <link href="/2018/08/13/Http%E5%AD%A6%E4%B9%A0%E4%B9%8BHttp%E7%AE%80%E4%BB%8B/"/>
      <url>/2018/08/13/Http%E5%AD%A6%E4%B9%A0%E4%B9%8BHttp%E7%AE%80%E4%BB%8B/</url>
      <content type="html"><![CDATA[<p>题目是Http，所以内容是基本的知识点，基本是复制粘贴。<br>但是因为有了博客就像通过博客记录下来，还是开一个吧。<br>掌握它的特性，消息结构，请求方法，状态码（有可能面试会问）</p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网（WWW:World Wide Web ）服务器传输超文本到本地浏览器的传送协议。</p><p>HTTP是一个基于TCP/IP通信协议来传递数据（HTML 文件, 图片文件, 查询结果等）。</p><a id="more"></a><h2 id="HTTP三点注意事项："><a href="#HTTP三点注意事项：" class="headerlink" title="HTTP三点注意事项："></a>HTTP三点注意事项：</h2><ul><li><p>HTTP是无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。</p></li><li><p>HTTP是媒体独立的：这意味着，只要客户端和服务器知道如何处理的数据内容，任何类型的数据都可以通过HTTP发送。客户端以及服务器指定使用适合的MIME-type内容类型。</p></li><li><p><strong>HTTP是无状态</strong>：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。</p></li></ul><h1 id="Http消息结构"><a href="#Http消息结构" class="headerlink" title="Http消息结构"></a>Http消息结构</h1><p>这一点在面试中遇到过，当时有点懵逼，没细看这里，所以总结下来。</p><h2 id="客户端请求报文"><a href="#客户端请求报文" class="headerlink" title="客户端请求报文"></a>客户端请求报文</h2><p>客户端发送一个HTTP请求到服务器的请求消息包括以下格式：<strong>请求行（request line）、请求头部（header）、空行</strong>和<strong>请求数据</strong>四个部分组成，下图给出了请求报文的一般格式。</p><p><img src="/2018/08/13/Http学习之Http简介/1.png" alt="客户端请求消息"></p><ol><li><p>请求行</p><p> 请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。比如 GET /data/info.html HTTP/1.1</p></li><li><p>请求头部 </p><p> HTTP客户程序(例如浏览器)，向服务器发送请求的时候必须指明请求类型(一般是GET或者 POST)。如有必要，客户程序还可以选择发送其他的请求头。大多数请求头并不是必需的，但Content-Length除外。对于POST请求来说 Content-Length必须出现。</p></li><li><p>空行</p><p> 它的作用是通过一个空行，告诉服务器请求头部到此为止。</p></li><li><p>请求数据</p><p> 若方法字段是GET，则此项为空，没有数据</p><p> 若方法字段是POST,则通常来说此处放置的就是要提交的数据</p></li></ol><p><img src="/2018/08/13/Http学习之Http简介/3.png" alt=""></p><h2 id="服务器响应报文"><a href="#服务器响应报文" class="headerlink" title="服务器响应报文"></a>服务器响应报文</h2><p>HTTP响应也由四个部分组成，分别是：<strong>状态行、消息报头、空行和响应正文</strong>。</p><p><img src="/2018/08/13/Http学习之Http简介/2.png" alt=""></p><ol><li><p>响应行</p><p> 响应行一般由协议版本、状态码及其描述组成 比如 HTTP/1.1 200 OK</p><p> 其中协议版本HTTP/1.1或者HTTP/1.0，200就是它的状态码，OK则为它的描述。</p></li><li><p>响应头</p><p> 响应头用于描述服务器的基本信息，以及数据的描述，服务器通过这些数据的描述信息，可以通知客户端如何处理等一会儿它回送的数据。</p></li><li><p>响应体</p><p> 响应体就是响应的消息体，如果是纯数据就是返回纯数据，如果请求的是HTML页面，那么返回的就是HTML代码，如果是JS就是JS代码，如此之类。</p></li></ol><p><img src="/2018/08/13/Http学习之Http简介/4.png" alt=""></p><h1 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h1><p>请求方法已经在另一篇笔记里有详细的总结，链接<br><a href="https://caihuazhj.github.io/2018/08/12/Http%E5%AD%A6%E4%B9%A0%E4%B9%8BGET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95/" target="_blank" rel="noopener">Http学习之GET方法与POST方法</a></p><h1 id="常见状态码"><a href="#常见状态码" class="headerlink" title="常见状态码"></a>常见状态码</h1><p>HTTP状态码由三个十进制数字组成，第一个十进制数字定义了状态码的类型，后两个数字没有分类的作用。</p><p>HTTP状态码共分为5种类型：</p><ul><li>1**      信息，服务器收到请求，需要请求者继续执行操作</li></ul><ul><li><p>2**      成功，操作被成功接收并处理</p></li><li><p>3**      重定向，需要进一步的操作以完成请求</p></li><li><p>4**      客户端错误，请求包含语法错误或无法完成请求</p></li><li><p>5**      服务器错误，服务器在处理请求的过程中发生了错误</p></li></ul><p>下面是常见的HTTP状态码：</p><ul><li><p>100 -  Continue 继续。客户端应继续其请求</p></li><li><p>200 - 请求成功</p></li><li><p>301 - 资源（网页等）被永久转移到其它URL</p></li><li><p>404 - 请求的资源（网页等）不存在</p></li><li><p>500 - 内部服务器错误</p></li></ul>]]></content>
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>Http学习之同步与异步</title>
      <link href="/2018/08/13/Http%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/"/>
      <url>/2018/08/13/Http%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
      <content type="html"><![CDATA[<p>同步：执行一个操作之后，等待结果，然后才继续执行后续的操作。</p><p>异步：执行一个操作后，可以去执行其他的操作，然后等待通知再回来执行刚才没执行完的操作。</p><p>阻塞：进程给CPU传达一个任务之后，一直等待CPU处理完成，然后才执行后面的操作。</p><p>非阻塞：进程给CPU传达任我后，继续处理后续的操作，隔断时间再来询问之前的操作是否完成。这样的过程其实也叫轮询</p><p>因为没有实际应用过，对这里的概念认识还是有些模糊，本质上是网络IO的知识点，socket是一直想认真学习的地方，下午认真看一下。</p>]]></content>
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> asyn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Http学习之GET方法与POST方法</title>
      <link href="/2018/08/12/Http%E5%AD%A6%E4%B9%A0%E4%B9%8BGET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95/"/>
      <url>/2018/08/12/Http%E5%AD%A6%E4%B9%A0%E4%B9%8BGET%E6%96%B9%E6%B3%95%E4%B8%8EPOST%E6%96%B9%E6%B3%95/</url>
      <content type="html"><![CDATA[<p>Http由七种请求方法，分别是：</p><ul><li>HEAD：与 GET 相同，但只返回 HTTP 报头，不返回文档主体。</li><li>PUT：上传指定的 URI 表示。</li><li>DELETE：删除指定资源。</li><li>OPTIONS：返回服务器支持的 HTTP 方法。</li><li>CONNECT：把请求连接转换到透明的 TCP/IP 通道。</li><li>GET：从指定的资源请求数据。</li><li>POST：向指定的资源提交要被处理的数据</li></ul><p>其中，使用最多的是GET和POST，面试中也经常会问到，无论是前端还是后端。以前对二者的认识相当相当浅显，这两天笔试均遇到了相关的知识，所以在这里认真学习，总结一下。</p><a id="more"></a><h2 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h2><p>查询字符串（名称/值对）是在 GET 请求的 URL 中发送的：</p><pre><code>例如： /test/demo_form.asp?name1=value1&amp;name2=value2</code></pre><p>有关 GET 请求的其他一些注释：</p><ul><li>GET 请求可被缓存</li><li>GET 请求保留在浏览器历史记录中</li><li>GET 请求可被收藏为书签</li><li>GET 请求不应在处理敏感数据时使用</li><li>GET 请求有长度限制 </li><li>GET 请求只应当用于取回数据</li></ul><h2 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h2><p>查询字符串（名称/值对）是在 POST 请求的 HTTP 消息主体中发送的：</p><p>例如：</p><pre><code>POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2</code></pre><p>有关 POST 请求的其他一些注释：</p><ul><li>POST 请求不会被缓存</li><li>POST 请求不会保留在浏览器历史记录中</li><li>POST 不能被收藏为书签</li><li>POST 请求对数据长度没有要求</li></ul><h2 id="二者详解，比较"><a href="#二者详解，比较" class="headerlink" title="二者详解，比较"></a>二者详解，比较</h2><p>参考 <a href="https://blog.csdn.net/zzk220106/article/details/78595108/" target="_blank" rel="noopener">https://blog.csdn.net/zzk220106/article/details/78595108/</a></p><h3 id="POST比GET更安全"><a href="#POST比GET更安全" class="headerlink" title="POST比GET更安全"></a>POST比GET更安全</h3><p>在上述中已经表明，get方法将传递参数直接拼接在URL中，而post方法是将参数放在HTTP消息主体中</p><h3 id="POST发送的数据更大"><a href="#POST发送的数据更大" class="headerlink" title="POST发送的数据更大"></a>POST发送的数据更大</h3><p>get方法有长度限制，但是有一个误区，就是<strong>http协议并未规定get和post的长度限制</strong> ，即get的最大长度限制是因为浏览器和web服务器限制了URL的长度（不是参数的长度）。</p><p>POST方法没有长度限制，同样，因为它的值通过浏览器header传输而不是url。</p><p>但是POST方法传递URL长度受限于服务器处理数据的能力，Tomcat默认2M，但是可以在server.xml文件中Connector标签下增加或修改 maxPostSize=”0”，此处0为不限制；</p><h4 id="各个浏览器和web服务器的最大长度总结"><a href="#各个浏览器和web服务器的最大长度总结" class="headerlink" title="各个浏览器和web服务器的最大长度总结"></a>各个浏览器和web服务器的最大长度总结</h4><h5 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h5><ol><li><p>IE：IE浏览器（Microsoft Internet Explorer） 对url长度限制是2083（2K+53），超过这个限制，则自动截断（若是form提交则提交按钮不起作用）。</p></li><li><p>firefox：firefox（火狐浏览器）的url长度限制为 65536字符，但实际上有效的URL最大长度不少于100,000个字符。 </p></li><li><p>chrome：chrome（谷歌）的url长度限制超过8182个字符返回本文开头时列出的错误。 </p></li><li><p>Safari：Safari的url长度限制至少为 80 000 字符。 </p></li><li><p>Opera：Opera 浏览器的url长度限制为190 000 字符。Opera9 地址栏中输入190000字符时依然能正常编辑。 </p></li></ol><h5 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h5><p>   Apache：Apache能接受url长度限制为8 192 字符。</p><h3 id="POST能发送更多的数据类型（GET只能发送ASCII字符）"><a href="#POST能发送更多的数据类型（GET只能发送ASCII字符）" class="headerlink" title="POST能发送更多的数据类型（GET只能发送ASCII字符）"></a>POST能发送更多的数据类型（GET只能发送ASCII字符）</h3><p>POST提交数据时有四种格式（HTTP请求头中的 Content-Type）：</p><ol><li><p>application/x-www-form-urlencoded</p><p> 浏览器的原生表单，如果不设置enctype属性，那么最终就会以这种方式提交数据。</p><p> 提交的数据按照key1=val1&amp;key2=val2的方式进行编码，key和val都进行了URL转码。</p></li><li><p>multipart/form-data</p><p> 提交数据时，设置表单的 enctype 等于 multipart/form-data。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。 </p><p> （Spring中实现文件上传时，也用到了这个参数，项目中实现excel上传也用到了）</p><p> 以上两种格式是浏览器原生支持的，默认的 Content-Type为application/x-www-form-urlencoded</p></li><li><p>application/json</p><p> 目前应用比较广，将复杂的数据可以转成json格式，方便后台处理</p></li><li><p>text/xml</p><p> 它是一种使用 HTTP 作为传输协议，XML 作为编码方式的远程调用规范,它的使用也很广泛，能很好的支持已有的 XML-RPC 服务。不过，XML 结构还是过于臃肿，一般场景用 JSON 会更灵活方便。</p></li></ol><h3 id="POST用于修改和写入数据，GET一般用于搜索排序和筛选之类的操作"><a href="#POST用于修改和写入数据，GET一般用于搜索排序和筛选之类的操作" class="headerlink" title="POST用于修改和写入数据，GET一般用于搜索排序和筛选之类的操作"></a>POST用于修改和写入数据，GET一般用于搜索排序和筛选之类的操作</h3><p>淘宝，支付宝的搜索查询都是get提交，目的是资源的获取，读取数据。</p><h3 id="POST比GET慢"><a href="#POST比GET慢" class="headerlink" title="POST比GET慢"></a>POST比GET慢</h3><h4 id="post请求的过程："><a href="#post请求的过程：" class="headerlink" title="post请求的过程："></a>post请求的过程：</h4><p>（1）浏览器请求tcp连接（第一次握手） </p><p>（2）服务器答应进行tcp连接（第二次握手） </p><p>（3）浏览器确认，并发送post请求头（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送） </p><p>（4）服务器返回100 Continue响应 </p><p>（5）浏览器发送数据 </p><p>（6）服务器返回200 OK响应 </p><h4 id="get请求的过程："><a href="#get请求的过程：" class="headerlink" title="get请求的过程："></a>get请求的过程：</h4><p>（1）浏览器请求tcp连接（第一次握手） </p><p>（2）服务器答应进行tcp连接（第二次握手） </p><p>（3）浏览器确认，并发送get请求头和数据（第三次握手，这个报文比较小，所以http会在此时进行第一次数据发送）</p><p>（4）服务器返回200 OK响应 </p><p>因此，理论上get的总耗是post的2/3左右，但是GET方法是可以缓存的。</p><h3 id="POST不能进行管道化传输"><a href="#POST不能进行管道化传输" class="headerlink" title="POST不能进行管道化传输"></a>POST不能进行管道化传输</h3><blockquote><p>在http/1.1中，有一种称为管道通信的方式进行速度优化：把需要发送到服务器上的所有请求放到输出队列中。<br>但是，这就有一个问题，那就是不安全。</p><p>如果一个管道中有10个连接，在发送出9个后，突然服务器告诉你，连接关闭了，此时客户端即使收到了前9个请求的答复，也会将这9个请求的内容清空，也就是说，白忙活了……此时，客户端的这9个请求需要重新发送。</p><p>这对于幂等请求（无论调用这个url多少次，都不会有不同的结果的HTTP方法）还好（比如get，多发送几次都没关系，每次都是相同的结果），如果是post这样的非幂等请求（比如支付的时候，多发送几次就惨了），肯定是行不通的。 </p><p>所以，post请求不能通过管道的方式进行通信！很有可能，post请求需要重新建立连接，这个过程不跟完全没优化的时候一样了么？所以，在可以使用get请求通信的时候，不要使用post请求，这样用户体验会更好，当然，如果有安全性要求的话，post会更好。</p><p>管道化传输在浏览器端的实现还需考证，貌似默认情况下大部分浏览器（除了opera）是不进行管道化传输的，除非手动开启！ </p></blockquote><blockquote><p><em>这个地方总结起来和原博客基本没有太大差别，直接复制过来了</em></p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过对GET与POST的详细解析之后，感觉之前掌握的知识还是太浅显了，二者的差别也不仅仅存在于安全不安全这方面。</p><p>在实际应用中，也要考虑实际需求来对这两种方法进行选择。<em>POST用于修改和写入数据，GET一般用于搜索排序和筛选之类的操作</em></p><p>实验室的项目里在写的时候直接全部用了POST，现在看来，有很多地方需要改进。</p><p>对于POST数据类型，json无疑现在应用比较广泛，后面应该单独再看一下。</p><p>multipart/form-data应用在文件上传的时候，这部分代码当时由同组的人实现，只是了解到了逻辑，却忽略了这些。并且在复习Spring的时候也涉及到了这一点，应当再审以下代码，把各个环节都弄清楚。</p>]]></content>
      
      <categories>
          
          <category> Http </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GET&amp;POST </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM学习之类加载机制</title>
      <link href="/2018/08/10/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
      <url>/2018/08/10/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
      <content type="html"><![CDATA[<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、 转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。</p><p>与那些在编译时需要进行连接工作的语言不同，在Java语言里面，类型的加载、 连接和初始化过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开<br>销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。<br><a id="more"></a></p><p><em>图片图片图片</em></p><h2 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h2><p>针对是否会触发初始化，类加载过程分为：类的主动引用和类的被动引用</p><ol><li><p><strong>主动引用</strong>（一定会触发初始化）：</p><ul><li><p>new一个类的对象</p></li><li><p>调用类的静态成员（除了final常量）和静态方法</p></li><li><p>使用java.lang.reflect包的方法对类进行反射调用</p></li><li><p>当初始化一个类，如果其父类没有被初始化，则先初始化他的父类，</p></li><li><p>当要执行某个程序时，一定先启动main方法所在的类</p></li></ul></li><li><p><strong>被动引用</strong>：</p><ul><li><p>当访问一个静态变量时，只有真正生命这个静态变量的类才会被初始化（通过子类引用父类的静态变量，不会导致子类初始化）</p></li><li><p>通过数组定义类应用，不会触发此类的初始化</p></li><li><p>引用常量(final类型)不会触发此类的初始化（常量在编译阶段就存入调用类的常量池中了）</p></li></ul></li></ol><h2 id="类加载机制"><a href="#类加载机制" class="headerlink" title="类加载机制"></a>类加载机制</h2><p>JVM把class文件加载到内存，并对数据进行校验、解析和初始化，最终形成jvm可以直接使用的java类型的过程。</p><ol><li><p><strong>加载</strong></p><p>将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区中的运行时数据结构，在堆中生成一个代表这个类的java.lang.Class对象，作为方法区类数据的访问入口。</p></li><li><p><strong>链接</strong>将java类的二进制代码合并到jvm的运行状态之中的过程</p><ol><li><p><strong>验证：</strong></p><p> 确保加载的类信息符合jvm规范，没有安全方面的问题。验证包括：文件格式、元数据、字节码、符号引用。</p></li><li><p><strong>准备：</strong></p><p>正式为类变量（static变量）分配内存并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。</p></li><li><p><strong>解析：</strong></p><p>虚拟机常量池内的符号引用替换为直接引用的过程。（比如String s =”aaa”,转化为 s的地址指向“aaa”的地址）</p></li></ol></li><li><p><strong>初始化</strong></p><p> 初始化阶段是执行类构造器&lt;clinit>()方法的过程。</p><p> <strong>&lt;clinit>()方法影响程序运行行为的特点和细节：</strong></p><ol><li><p>&lt;clinit>()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static块）中的语句合并产生的。</p></li><li><p>当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先初始化其父类的初始化。</p></li><li><p>&lt;clinit>()方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit>()方法。</p><p>接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成&lt;clinit>()方法。</p><p>但接口与类不同的是，执行接口的&lt;clinit>()方法不需要先执行父接口的&lt;clinit>()方法。<br>只有当父接口中定义的变量使用时，父接口才会初始化。</p><p>另外，接口的实现类在初始化时也一样不会执行接口的&lt;clinit>()方法。</p></li><li><p>虚拟机会保证一个类的&lt;clinit>()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的&lt;clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行&lt;clinit>()方法完毕。</p></li></ol></li></ol><h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><ol><li><p><strong>虚拟机角度</strong></p><p>从Java虚拟机的角度来讲，只存在两种不同的类加载器：</p><p><strong>启动类加载器</strong>（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分；</p><p><strong>其他的类加载器</strong>，这些类加载器都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。</p></li><li><p><strong>程序员角度</strong></p><ol><li><p>启动类加载器（Bootstrap<br>ClassLoader）：前面已经介绍过，这个类将器负责将存放在＜JAVA_HOME＞\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。<br>启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可。</p></li><li><p>扩展类加载器（Extension<br>ClassLoader）：这个加载器由sun.misc.Launcher\$ExtClassLoader实现，它负责加载＜JAVA_HOME＞\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p></li><li><p>应用程序类加载器（Application<br>ClassLoader）：这个类加载器由sun.misc.Launcher \$AppClassLoader实现。<br>由于这个类加载器是ClassLoader中的getSystemClassLoader（）方法的返回值，所以一般也称它为系统类加载器。<br>它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p></li></ol></li></ol><p><strong>双亲委派模型</strong></p><p><img src="/2018/08/10/JVM学习之类加载机制/media/0cb5665e609874d9e096d5e01b82c870.png" alt=""></p><p>双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器，一般使用组合的关系来复用父加载器代码</p><p><strong>逻辑：</strong></p><p>先检查是否已经被加载过，若没有加载则调用父加载器的loadClass（）方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出ClassNotFoundException异常后，再调用自己的findClass()方法进行加载。</p><p><strong>附：类加载过程需要考虑哪些问题？</strong></p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM学习之GC与内存分配策略</title>
      <link href="/2018/08/09/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8BGC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
      <url>/2018/08/09/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8BGC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
      <content type="html"><![CDATA[<p>关于GC和内存分配，JAVA程序员觉得太重要了，千万不能自己管理。C++程序员觉得太重要了，一定要自己管理。</p><p>经过半个多世纪的发展，目前内存的动态分配与内存回收技术已经相当成熟，一切看起来都进入了“自动化”时代，那为什么我们还要去了解GC和内存分配呢？答案很简单：当需要排查各种内存溢出、 内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些“自动化”的技术实施必要的监控和调节。</p><a id="more"></a><p>说起垃圾收集（Garbage Collection,GC），需要思考3件事情：</p><ul><li><p>哪些内存需要回收？</p></li><li><p>什么时候回收？</p></li><li><p>如何回收？</p></li></ul><hr><h2 id="对象已经死了吗"><a href="#对象已经死了吗" class="headerlink" title="对象已经死了吗"></a>对象已经死了吗</h2><p>判断方法</p><ol><li><p><strong>引用计数法：</strong>引用加1，失效减1，但是无法解决互相引用的问题</p></li><li><p><strong>可达性分析（GC Roots）：</strong>从GC Roots向下搜索不可达，并且经历两次标记后的就是不可用的。</p><p><strong>在Java语言中，可作为GC Roots的对象包括下面几种：</strong>  </p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。  </li><li>方法区中类静态属性引用的对象。  </li><li>方法区中常量引用的对象。  </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul></li><li><p><strong>两次标记：是否有必要执行finalize（）方法：</strong>当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”；如果有必要执行，则加入F-Queue中。（此处需要详细再学习）</p></li></ol><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>主要用于废弃常量和无用的类。</p><ol><li>满足下面3个条件才能算是“无用的类”：</li></ol><pre><code>-  该类所有的实例都已经被回收，也就是Java堆中不存在类的任何实例。-  加载该类的ClassLoader已经被回收。-  该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</code></pre><h2 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h2><ol><li><p><strong>标记-清除法：</strong></p><p>字面意思，缺点为会产生碎片</p></li><li><p><strong>复制算法（空间代价大）：</strong></p><p>将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，默认康健8：1.当survivor空间不够用时，会依赖老年代进行担保。</p></li><li><p><strong>标记-整理算法：</strong></p><p>让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p><p><em>一般新生代使用复制算法，老年代使用另外两种。</em></p></li></ol><h2 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h2><p><em>此处要补垃圾收集器图片</em></p><ol><li><strong>Serial/SerialOld收集器</strong></li></ol><pre><code>单线程，stop the world，适合client模式下的虚拟机</code></pre><ol start="2"><li><strong>ParNew收集器</strong></li></ol><pre><code>Serial的多线程版本，Server模式下首选的新生代收集器，目前只有他能和CMS配合工作。</code></pre><ol start="3"><li><strong>Parallel Scavenge/Parallel Old收集器</strong></li></ol><pre><code>关注吞吐量</code></pre><ol start="4"><li><p><strong>CMS收集器</strong></p><p>以获得最短回收停顿时间为目标，基于标记-清除算法</p><p><strong>步骤：</strong></p><p>初始标记：stop the world</p><p>并发标记：耗时</p><p>重新标记：stop the world</p><p>并发清除：耗时</p></li></ol><pre><code>**缺点：**对CPU资源敏感，无法处理浮动垃圾，碎片</code></pre><ol start="5"><li><p><strong>G1收集器</strong></p><p><strong>特点：</strong>并行与并发（使用多个CPU缩短stop-the-world的时间）、分代收集、空间整合（整体看来标记-整理，局部（Region）来看复制算法）、可预测的停顿。</p><p><strong>Region：</strong>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。同时每一个region有一个RememberedSet来避免全盘扫描。</p><p><strong>步骤：</strong>初始标记、并发标记、最终标记、筛选回收</p></li><li><p><strong>GC日志</strong></p><p><em>笔记未记录</em></p></li></ol><h2 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h2><ol><li><strong>MinorGC与FullGC</strong></li></ol><pre><code>**新生代GC（MinorGC）：**指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。  **老年代GC（Major GC/Full GC）：**指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。 Major GC的速度一般会比Minor GC慢10倍以上。</code></pre><ol><li><p><strong>内存分配策略</strong></p><ol><li><p>优先在新生代eden上分配（多线程时在TLAB上分配）</p></li><li><p>大对象直接进入老年代，大对象指长字符串或数组；</p></li><li><p>对于经过Minor GC后，survivor能接收的将被移到survivor中，并且年龄加1，否则分配到老年代中去；默认15岁进入老年代（如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代）；</p></li><li><p>空间分配担保</p><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。 如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p></li></ol></li></ol>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JVM学习之JAVA内存区域</title>
      <link href="/2018/08/09/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8BJAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/"/>
      <url>/2018/08/09/JVM%E5%AD%A6%E4%B9%A0%E4%B9%8BJAVA%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F/</url>
      <content type="html"><![CDATA[<p>对于Java程序员来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄漏和内存溢出问题，由虚拟机管理内存这一切看起来都很美好。 不过，也正是因为Java程序员把内存控制的权力交给了Java虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会成为一项异常艰难的工作。</p><a id="more"></a><h2 id="JAVA内存区域"><a href="#JAVA内存区域" class="headerlink" title="JAVA内存区域"></a>JAVA内存区域</h2><p>图片位置</p><p>JAVA内存区域可分为如下几部分：方法区、java堆、Java栈、本地方法栈、程序计数器、直接内存</p><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>当前线程所执行的字节码的行号指示器。如果线程正在执行JAVA方法，记录虚拟机字节码指令的地址；如果是Native方法，则为空。没有OutOfMemoeryRrror</p><h3 id="Java虚拟机栈（java栈）"><a href="#Java虚拟机栈（java栈）" class="headerlink" title="Java虚拟机栈（java栈）"></a>Java虚拟机栈（java栈）</h3><p>描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个栈帧（stackframe）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。 OutOfMemoeryRrror/StackOverFlowError.</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、 byte、 char、short、 int、float、 long、 double）、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。</p><p>其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>虚拟机使用到的native方法服务，没有强制规定OutOfMemoeryRrror/StackOverFlowError.</p><h3 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h3><p>JAVA堆是java虚拟机所管理的内存的最大的一块，唯一目的是存放对象实例。</p><blockquote><p>虚拟机规范原文：The heap is the runtime data area from which memory for all classinstances and arrays isallocated。</p></blockquote><p><strong>java堆是垃圾收集管理的主要区域</strong>，可细分为新生代（Eden空间，from survivor，to survivor）和老年代。对于线程共享可划分出多个线程共享的分配缓冲区TLAB。Java堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可。空间可通过-Xmx，-Xms控制。OutOfMemoeryRrror</p><h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>   各线程共享，存储以背虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。程序员更愿意把这里称为永久代，但是在jdk8中，已将永久代移除，改为元空间，不在虚拟机分配内存，而使用本地内存。OutOfMemoeryRrror</p><h3 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h3><p>是方法区的一部分，用于存放编译期生成的各种字面量和符号引用。具有动态性，在程序运行期间也可以将新的常量放入池中。（String类的intern（）方法）。</p><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p>不是虚拟机运行时数据区的一部分，可以通过NI/O的Channel和Buffer的I/O方式直接分配堆外内存，使用DirectByteBuffer作为这块内存的引用进行操作。</p><h2 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h2><p><em>此处指虚拟机执行类加载过程之后，为对象分配内存的过程，内容包括分配方法及对象的内存布局，具体的类加载过程在后面的笔记中会有整理。</em></p><h3 id="通过new创建的对象"><a href="#通过new创建的对象" class="headerlink" title="通过new创建的对象"></a>通过new创建的对象</h3><p>虚拟机遇到new指令时，首先会执行类加载过程，然后为新生对象分配内存初始化零值进行必要设置，然后java程序才会执行init方法</p><h4 id="分配内存方法"><a href="#分配内存方法" class="headerlink" title="分配内存方法"></a>分配内存方法</h4><ol><li><p>指针碰撞，空闲列表</p></li><li><p>并发条件下：解决这个问题有两种方案：</p><ol><li><p>对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性</p></li><li><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX：+/-UseTLAB参数来设定。</p></li></ol></li></ol><h4 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h4><p>  保证对象的实例字段在JAVA代码中可以不赋初始值直接使用。</p><h4 id="虚拟机对对象进行必要设置"><a href="#虚拟机对对象进行必要设置" class="headerlink" title="虚拟机对对象进行必要设置"></a>虚拟机对对象进行必要设置</h4><p>  例如这个对象是哪个类的实例、 如何才能找到类的元数据信息、 对象的哈希码、对象的GC分代年龄等信息。 这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><ol><li><p>第一部分用于<strong>存储对象自身的运行时数据</strong>，如哈希码（HashCode）、GC分代年龄、 锁状态标志、 线程持有的锁、 偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32bit和64bit，官方称它为“Mark Word”。</p></li><li><p><strong>类型指针：</strong>即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></li></ol><h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>实例数据部分时对象真正存储的有效信息，也就是各个字段的内容：HotSpot虚拟机默认的分配策略为longs/doubles、ints、 shorts/chars、bytes/booleans、 oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true（默认为true），那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。</p><h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>   HotSpotVM的自动内存管理系统要求对象起始地址必须时8字节的整数倍。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p><em>未整理，后续补充</em></p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JAVA基础之Object类学习及公共方法整理</title>
      <link href="/2018/08/09/JAVA%E5%9F%BA%E7%A1%80%E4%B9%8BObject%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
      <url>/2018/08/09/JAVA%E5%9F%BA%E7%A1%80%E4%B9%8BObject%E7%B1%BB%E5%AD%A6%E4%B9%A0%E5%8F%8A%E5%85%AC%E5%85%B1%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<p>面试过程中，经常会问到equals方法和==的区别，还有为什么要重写equals方法和hashCode方法，之前只是简单搜了一下，并没有彻底的理解，也记不住到底有啥区别（真是不走心）。今天在复习过程中又留意到这一点，决定仔细学习一下。</p><p>这篇主要详细写了equals，hashCode和toString方法。<br>笔记参考 《Effective Java》 第三章</p><h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><p>Object类是所有类的祖先，包括数组。</p><blockquote><p>虽然是一个具体类，但是设计它主要是为了拓展。它所有非final方法(equals,hashCode,toString,clone和finalize)都有明确的通用约定，因为他们被设计成是要被覆盖（override）的。                         —《EFFECTIVE JAVA 第三章》</p></blockquote><a id="more"></a><h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><p>默认比较的是两个对象的引用是否相等，即是否指向同一个对象（两个对象的地址是否相同）</p><p><strong>什么情况下不需要重写equals方法</strong></p><ul><li>类的每个实例本质上都是唯一的。</li><li>不关心类是否提供了“逻辑相等”的测试功能</li><li>超类已经覆盖了equals，从超类继承过来的行为对于子类也是合适的</li><li>类是私有的或是包级私有的，可以确定塔的equals方法永远不会被调用。</li></ul><p>&ensp;&ensp;&ensp;&ensp;当我们想利用equals方法比较值对象的引用时，希望知道他们在逻辑上是否相等，而不是想了解他们是否指向同一个对象时，就需要覆盖equals方法。</p><p><strong>并且要遵循以下约定：</strong></p><ul><li>自反性</li></ul><p>&ensp;&ensp;&ensp;&ensp;举个栗子，如果违反，在collection中添加元素时，contains方法会告诉你刚才添加的元素不存在</p><ul><li><p>对称性</p></li><li><p>传递性</p></li><li><p>一致性</p></li></ul><p>&ensp;&ensp;&ensp;&ensp;相等的永远相等，不相等的永远不相等</p><p><strong>高质量equals方法诀窍：</strong></p><ul><li>使用==操作符检查“参数是否为这个对象的引用”</li><li>使用instancof操作符检查“参数是否为正确的类型”</li><li>把参数转换成正确的类型</li><li>对于该类中的每个“关键（significant）”域，检查参数中的域是否与该对象中对应的域相匹配。</li></ul><p><strong>另外还需要考虑</strong></p><ul><li>对于非float和double类型的基本类型的域，可以直接使用==操作符进行比较；</li><li>对于对象引用域，可以递归调用equals方法；</li><li>float和double都有对应的compare方法；</li><li>避免空指针异常</li><li>为获得最佳性能，建议从最有可能出错的域开始比较</li><li>Last But Not Least 检查是否满足equals方法的约定</li></ul><p><strong>最终忠告</strong></p><ul><li>覆盖equals方法一定要重写hashCode方法</li><li>不要企图让equals方法太过智能</li><li>不要将equals声明中的参数替换为其它类型</li></ul><h2 id="hashCode方法"><a href="#hashCode方法" class="headerlink" title="hashCode方法"></a>hashCode方法</h2><p>默认情况下hashCode返回的结果与存储地址有一定关联。（hashCode返回的就是对象的存储地址，这种看法是不全面的）</p><p><strong>设计原则</strong></p><ul><li>在程序执行期间，只要equals方法的比较操作用到的信息没有被修改，那么对这同一个对象调用多次，hashCode方法必须始终如一地返回同一个整数。</li><li>如果两个对象根据equals方法比较是相等的，那么调用两个对象的hashCode方法必须返回相同的整数结果。</li><li>如果两个对象根据equals方法比较是不等的，则hashCode方法不一定得返回不同的整数。</li></ul><p>第一条不太好理解，《Java编程思想》中的第495页也有同第一条类似的一段话：</p><blockquote><p>设计hashCode()时最重要的因素就是：无论何时，对同一个对象调用hashCode()都应该产生同样的值。如果在讲一个对象用put()添加进HashMap时产生一个hashCdoe值，而用get()取出时却产生了另一个hashCode值，那么就无法获取该对象了。所以如果你的hashCode方法依赖于对象中易变的数据，用户就要当心了，因为此数据发生变化时，hashCode()方法就会生成一个不同的散列码。</p></blockquote><p>我们可以看一段代码<br>    package TestObject;</p><pre><code>import java.util.HashMap;public class People {    private String name;    private int age;    public People(String name, int age) {        this.name = name;        this.age = age;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    @Override    public int hashCode() {        return name.hashCode()*37+age;    }    @Override    public boolean equals(Object obj) {        return this.name.equals(((People)obj).name) &amp;&amp; this.age== ((People)obj).age;    }    public static void main(String[] args) {        People people = new People(&quot;jack&quot;,13);        System.out.println(people.hashCode());        HashMap&lt;People,Integer&gt; map = new HashMap&lt;&gt;();        map.put(people,1);        people.setAge(11);        System.out.println(map.get(people));    }}</code></pre><p>代码中，使用People的age属性进行构建hashCode方法，当改变age时，再按key去输出value时，为空。</p><p>故在设计hashCode方法和equals方法的时候，如果对象中的数据易变，则最好在equals方法和hashCode方法中不要依赖于该字段。</p><p>第二条讲述了为什么覆盖equals方法一定要重写hashCode方法</p><p>第三条要求为不同的对象产生不同的hashCode值。通常在HashMap,HashSet,HashTable中应用比较广，他们的hashCode方法及过程要好好总结以下。<strong>next Steps</strong></p><h2 id="toString方法"><a href="#toString方法" class="headerlink" title="toString方法"></a>toString方法</h2><p>默认输出对象地址  getClass().getName() + ‘@’ + Integer. toHexString(hashCode())</p><p>建议重写</p><h2 id="clone方法"><a href="#clone方法" class="headerlink" title="clone方法"></a>clone方法</h2><pre><code>protected native Object clone() throws CloneNotSupportedException;</code></pre><p>谨慎重写</p><h2 id="finalize方法"><a href="#finalize方法" class="headerlink" title="finalize方法"></a>finalize方法</h2><p>一般不必要</p><hr><p>写了这么多知识点，再总结以下关于此部分的面试题</p><h2 id="equals和-的区别"><a href="#equals和-的区别" class="headerlink" title="equals和==的区别"></a>equals和==的区别</h2><p>参考 <a href="https://www.cnblogs.com/dolphin0520/p/3592500.html" title="浅谈Java中的equals和==" target="_blank" rel="noopener">https://www.cnblogs.com/dolphin0520/p/3592500.html</a></p><h3 id="对于操作符”-”"><a href="#对于操作符”-”" class="headerlink" title="对于操作符”==”"></a>对于操作符”==”</h3><p>《Java编程思想》中有这样一句话</p><blockquote><p>关系操作符生成的是一个boolean结果，它们计算的是操作数的值之间的关系</p></blockquote><p>对于JAVA中的基本数据类型的变量，变量直接存储的是“值”，因此在用关系操作符==来进行比较时，比较的就是 “值” 本身。要注意浮点型和整型都是有符号类型的，而char是无符号类型的（char类型取值范围为0~2^16-1)</p><p>而对于非基本数据类型的变量（在一些书籍中称作为引用类型的变量）存储的并不是 “值”本身，而是于其关联的对象在内存中的地址。</p><p><strong>此处引申JAVA引用类型，后记</strong></p><h3 id="对于equals方法"><a href="#对于equals方法" class="headerlink" title="对于equals方法"></a>对于equals方法</h3><p>在上文中提到，在Object类中，equals方法是用来比较两个对象的引用是否相等，即是否指向同一个对象。</p><p>String类对equals方法进行了重写，用来比较指向的字符串对象所存储的字符串是否相等。</p><p>其他的一些类诸如Double，Date，Integer等，都对equals方法进行了重写用来比较指向的对象所存储的内容是否相等。</p><h3 id="最终总结"><a href="#最终总结" class="headerlink" title="最终总结"></a>最终总结</h3><ol><li>对于==，如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；</li></ol><p>　　如果作用于引用类型的变量，则比较的是所指向的对象的地址</p><ol start="2"><li>对于equals方法，注意：equals方法不能作用于基本数据类型的变量</li></ol><p>　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；</p><p>　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JAVA基础 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HashMap面试</title>
      <link href="/2018/08/09/HashMap%E9%9D%A2%E8%AF%95/"/>
      <url>/2018/08/09/HashMap%E9%9D%A2%E8%AF%95/</url>
      <content type="html"><![CDATA[<h2 id="HashMap面试常问知识点总结"><a href="#HashMap面试常问知识点总结" class="headerlink" title="HashMap面试常问知识点总结"></a>HashMap面试常问知识点总结</h2><p>HashMap的底层主要是基于数组和链表来实现的，它之所以有相当快的查询速度主要是因为它是通过计算散列码来决定存储的位置。HashMap中主要是通过key的hashCode来计算hash值的，只要hashCode相同，计算出来的hash值就一样。如果存储的对象对多了，就有可能不同的对象所算出来的hash值是相同的，这就出现了所谓的hash冲突。学过数据结构的同学都知道，解决hash冲突的方法有很多，HashMap底层是通过链表来解决hash冲突的。</p><p>面试基本都会问，是真滴重要。<br><a id="more"></a></p><h3 id="hashmap为什么是数组＋链表，不是数组加数组"><a href="#hashmap为什么是数组＋链表，不是数组加数组" class="headerlink" title="hashmap为什么是数组＋链表，不是数组加数组"></a>hashmap为什么是数组＋链表，不是数组加数组</h3><p>数组的好处是可以根据下标快速的找到对应的元素。链表的好处在于添加、删除方便，不需要移动元素。</p><h3 id="怎样减少hash碰撞，给出具体方案"><a href="#怎样减少hash碰撞，给出具体方案" class="headerlink" title="怎样减少hash碰撞，给出具体方案"></a>怎样减少hash碰撞，给出具体方案</h3><p>使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性使得能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择</p><p>1.增大 <strong>映射空间/原空间</strong> 的大小</p><p>2.尽可能把原数据集均匀映射到较小空间</p><p>3.结合原空间数据的数据特征制定hash函数</p><h3 id="数组为什么是连续存储的"><a href="#数组为什么是连续存储的" class="headerlink" title="数组为什么是连续存储的"></a>数组为什么是连续存储的</h3><p>连续存储为了查找方便，HashMap此处使用空间换取时间</p><h3 id="数组的初始长度为什么是16"><a href="#数组的初始长度为什么是16" class="headerlink" title="数组的初始长度为什么是16"></a>数组的初始长度为什么是16</h3><p><em>此处仅仅为简单描述，不再详细记录</em></p><ol><li>jdk8中resize（）使用h &amp; (table.length - 1)，计算新索引的位置，如果结果是0，位置不变；如果结果是1，位置伟原索引+oldtable.length</li><li>hashmap长度要求为2的n次幂，在第一点中，计算索引位置要求这样；另外，如果不是2的n次幂，容易产生冲突，并且分布不均匀。 </li></ol><h3 id="HashMap在并发情况下，会出现什么问题（为什么hashmap不是线程安全的）"><a href="#HashMap在并发情况下，会出现什么问题（为什么hashmap不是线程安全的）" class="headerlink" title="HashMap在并发情况下，会出现什么问题（为什么hashmap不是线程安全的）"></a>HashMap在并发情况下，会出现什么问题（为什么hashmap不是线程安全的）</h3><ol><li><p>如果多个线程同时使用put方法添加元素</p><p> 假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。</p></li></ol><ol><li><p>如果多个线程同时检测到元素个数超过数组大小*loadFactor</p><p> 这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。</p></li></ol><p>另外，在扩容时（resize（）），由于采用头插法，会使链表出现闭环。</p><h3 id="HashMap参数"><a href="#HashMap参数" class="headerlink" title="HashMap参数"></a>HashMap参数</h3><h4 id="容量参数："><a href="#容量参数：" class="headerlink" title="容量参数："></a>容量参数：</h4><pre><code>static final int _DEFAULT\_INITIAL\_CAPACITY_ = 1 \&amp;lt;\&amp;lt; 4; // aka 16static final int _MAXIMUM\_CAPACITY_ = 1 \&amp;lt;\&amp;lt; 30;static final float _DEFAULT\_LOAD\_FACTOR_ = 0.75f;</code></pre><p>当entry的数量\&gt;= DEFAULT_INITIAL_CAPACITY* DEFAULT_LOAD_FACTOR时，扩容并且resize（）；</p><h4 id="树形化参数："><a href="#树形化参数：" class="headerlink" title="树形化参数："></a>树形化参数：</h4><pre><code>static final int _TREEIFY\_THRESHOLD_ = 8;static final int _UNTREEIFY\_THRESHOLD_ = 6;static final int _MIN\_TREEIFY\_CAPACITY_ = 64;</code></pre><h3 id="TREEIFY与RESIZE"><a href="#TREEIFY与RESIZE" class="headerlink" title="TREEIFY与RESIZE"></a>TREEIFY与RESIZE</h3><p>当好多bin被映射到同一个桶时，如果这个桶中bin的数量小于TREEIFY_THRESHOLD当然不会转化成树形结构存储；</p><p>如果这个桶中bin的数量大于了 TREEIFY_THRESHOLD ，但是capacity小于MIN_TREEIFY_CAPACITY 则依然使用链表结构进行存储，此时会对HashMap进行扩容；（为了避免进行扩容、树形化选择的冲突，这个值不能小于 4 * TREEIFY_THRESHOLD）</p><p>如果capacity大于了MIN_TREEIFY_CAPACITY ，则会进行树化。</p>]]></content>
      
      <categories>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HashMap </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Redis基础</title>
      <link href="/2018/08/08/Redis%E5%9F%BA%E7%A1%80/"/>
      <url>/2018/08/08/Redis%E5%9F%BA%E7%A1%80/</url>
      <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><p>Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。<br>Redis 是一个使用 C 语言写成的，开源的 key-value 数据库。。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。目前，Vmware在资助着redis项目的开发和维护。 </p><p>目前没有图片<br><a id="more"></a></p><hr><h2 id="Redis-优势"><a href="#Redis-优势" class="headerlink" title="Redis 优势"></a>Redis 优势</h2><ul><li><strong>性能极高</strong> Redis能读的速度是110000次/s,写的速度是81000次/s 。</li><li><strong>丰富的数据类型</strong> Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li><li><strong>原子</strong> Redis的所有操作都是原子性的，意思就是要么成功执行要么失败完全不执行。单个操作是原子性的。多个操作也支持事务，即原子性，通过MULTI和EXEC指令包起来。</li><li><strong>丰富的特性</strong> Redis还支持 publish/subscribe, 通知, key 过期等等特性。</li></ul><h2 id="Redis数据类型"><a href="#Redis数据类型" class="headerlink" title="Redis数据类型"></a>Redis数据类型</h2><ul><li>String</li><li>Hash</li><li>List</li><li>Set</li><li>ZSet</li></ul><h2 id="Redis底层数据结构"><a href="#Redis底层数据结构" class="headerlink" title="Redis底层数据结构"></a>Redis底层数据结构</h2><h3 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h3><h4 id="简单动态字符串结构"><a href="#简单动态字符串结构" class="headerlink" title="简单动态字符串结构"></a>简单动态字符串结构</h4><ol><li><p>len变量，用于记录buf中已经使用的空间长度（这里指出Redis的长度为5）</p></li><li><p>free变量，用于记录buf中还空余的空间（初次分配空间，一般没有空余，在对字符串修改的时候，会有剩余空间出现）</p></li><li><p>buf字符数组，用于记录我们的字符串（记录Redis）</p></li></ol><h4 id="SDS与C字符串的区别"><a href="#SDS与C字符串的区别" class="headerlink" title="SDS与C字符串的区别"></a>SDS与C字符串的区别</h4><ol><li><p><strong>获取字符串长度（SDSO（1）/C字符串O(n)）</strong></p><p>传统的C字符串使用长度为N+1的字符串数组来表示长度为N的字符串，所以为了获取一个长度为C字符串的长度，必须遍历整个字符串。</p><p>和C字符串不同，SDS的数据结构中，有专门用于保存字符串长度的变量，我们可以通过获取len属性的值，直接知道字符串长度。</p></li><li><p><strong>杜绝缓冲区溢出</strong></p><p>当我们需要对一个SDS进行修改的时候，redis会在执行拼接操作之前，预先检查给定SDS空间是否足够，如果不够，会先拓展SDS的空间，然后再执行拼接操作</p></li><li><p><strong>减少修改字符串时带来的内存重分配次数</strong></p><p>预分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次</p></li><li><p><strong>惰性空间释放</strong></p><p>我们在观察SDS的结构的时候可以看到里面的free属性，是用于记录空余空间的。我们除了在拓展字符串的时候会使用到free来进行记录空余空间以外，在对字符串进行收缩的时候，我们也可以使用free属性来进行记录剩余空间，这样做的好处就是避免下次对字符串进行再次修改的时候，需要对字符串的空间进行拓展。</p><p>然而，我们并不是说不能释放SDS中空余的空间，SDS提供了相应的API，让我们可以在有需要的时候，自行释放SDS的空余空间。</p><p>通过惰性空间释放，SDS避免了缩短字符串时所需的内存重分配操作，并未将来可能有的增长操作提供了优化</p></li><li><p><strong>二进制安全</strong></p><p>Redis中，不是靠空字符来判断字符串的结束的，而是通过len这个属性。那么，即便是中间出现了空字符对于SDS来说，读取该字符仍然是可以的。</p></li><li><p><strong>兼容部分C字符串函数</strong></p><p>虽然SDS的API都是二进制安全的，但他们一样遵循C字符串以空字符串结尾的惯例。</p></li></ol><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表在Redis中的应用非常广泛，比如列表键的底层实现之一就是链表。当一个列表键包含了数量较多的元素，又或者列表中包含的元素都是比较长的字符串时，Redis就会使用双向链表作为列表键的底层实现。</p><p>链表的特性</p><ul><li><p>双端：链表节点带有prev和next指针，获取某个节点的前置节点和后置节点的时间复杂度都是O（N）</p></li><li><p>无环：表头节点的prev指针和表尾节点的next都指向NULL，对立案表的访问时以NULL为截止</p></li><li><p>表头和表尾：因为链表带有head指针和tail指针，程序获取链表头结点和尾节点的时间复杂度为O(1)</p></li><li><p>长度计数器：链表中存有记录链表长度的属性len</p></li><li><p>多态：链表节点使用void*指针来保存节点值，并且可以通过list结构的dup、free、match三个属性为节点值设置类型特定函数。</p></li></ul><h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对的抽象数据结构。　</p><p>在字典中，一个键（key）可以和一个值（value）进行关联，字典中的每个键都是独一无二的。在C语言中，并没有这种数据结构，但是Redis<br>中构建了自己的字典实现。</p><p>Key的存储为hash值，利用拉链法解决hash冲突 。</p><p>哈希表空间分配规则：</p><p>如果执行的是拓展操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂</p><p>如果执行的是收缩操作，那么ht[1] 的大小为第一个大于等于ht[0] 的2的n次幂</p><h4 id="Rehash"><a href="#Rehash" class="headerlink" title="Rehash"></a>Rehash</h4><h5 id="渐进式rehash"><a href="#渐进式rehash" class="headerlink" title="渐进式rehash"></a>渐进式rehash</h5><p>在实际开发过程中，rehash<br>操作并不是一次性、集中式完成的，而是分多次、渐进式地完成的。</p><p>渐进式rehash 的详细步骤：</p><p>1、为ht[1] 分配空间，让字典同时持有ht[0]和ht[1]两个哈希表</p><p>2、在几点钟维持一个索引计数器变量rehashidx，并将它的值设置为0，表示rehash 开始</p><p>3、在rehash<br>进行期间，每次对字典执行CRUD操作时，程序除了执行指定的操作以外，还会将ht[0]中的数据rehash<br>到ht[1]表中，并且将rehashidx加一</p><p>4、当ht[0]中所有数据转移到ht[1]中时，将rehashidx 设置成-1，表示rehash 结束</p><p>采用渐进式rehash 的好处在于它采取分而治之的方式，避免了集中式rehash<br>带来的庞大计算量。</p><h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><p>跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。跳跃表是一种随机化的数据,跳跃表以有序的方式在层次化的链表中保存元素，效率和平衡树媲美<br>——查找、删除、添加等操作都可以在对数期望时间下完成，并且比起平衡树来说，跳跃表的实现要简单直观得多。</p><p>Redis只在两个地方用到了跳跃表，一个是实现有序集合键，另外一个是在集群节点中用作内部数据结构。</p><ul><li><p>跳跃表是有序集合的底层实现之一</p></li><li><p>主要有zskiplist 和zskiplistNode两个结构组成</p></li><li><p>每个跳跃表节点的层高都是1至32之间的随机数</p></li><li><p>在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的对象必须是唯一的</p></li><li><p>节点按照分值的大小从大到小排序，如果分值相同，则按成员对象大小排序</p></li></ul><h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><p>intset在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis中的升级策略来解决</p><p>1、encoding：用于定义整数集合的编码方式</p><p>2、length：用于记录整数集合中变量的数量</p><p>3、contents：用于保存元素的数组，虽然我们在数据结构图中看到，intset将数组定义为int8_t，但实际上数组保存的元素类型取决于encoding</p><p>在上述数据结构图中我们可以看到，intset在默认情况下会帮我们设定整数集合中的编码方式，但是当我们存入的整数不符合整数集合中的编码格式时，就需要使用到Redis中的升级策略来解决</p><p>Intset 中升级整数集合并添加新元素共分为三步进行：</p><ol><li><p>根据新元素的类型，扩展整数集合底层数组的空间大小，并为新元素分配空间</p></li><li><p>将底层数组现有的所有元素都转换成新的编码格式，重新分配空间</p></li><li><p>将新元素加入到底层数组中</p></li></ol><p><strong>整数集合升级的好处</strong></p><p>1、提升灵活性</p><p>2、节约内存</p><h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是列表键和哈希键的底层实现之一。当一个列表键只把汗少量列表项，并且每个列表项要么就是小整数，要么就是长度比较短的字符串，那么Redis<br>就会使用压缩列表来做列表键的底层实现。</p><p>1、zlbytes:用于记录整个压缩列表占用的内存字节数</p><p>2、zltail：记录要列表尾节点距离压缩列表的起始地址有多少字节</p><p>3、zllen：记录了压缩列表包含的节点数量。</p><p>4、entryX：要说列表包含的各个节点</p><p>5、zlend：用于标记压缩列表的末端</p><p>压缩列表是一种为了节约内存而开发的顺序型数据结构</p><p>压缩列表被用作列表键和哈希键的底层实现之一</p><p>压缩列表可以包含多个节点，每个节点可以保存一个字节数组或者整数值</p><p>添加新节点到压缩列表，可能会引发连锁更新操作。</p><h2 id="Redis面试题"><a href="#Redis面试题" class="headerlink" title="Redis面试题"></a>Redis面试题</h2><h3 id="redis实现持久化的方式"><a href="#redis实现持久化的方式" class="headerlink" title="redis实现持久化的方式"></a>redis实现持久化的方式</h3><ol><li>RDB持久化：将Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化</li><li>AOF持久化：将Reids的操作日志以追加的方式写入文件（append only file）</li></ol><h4 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h4><p>   RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。保存文件名为dump.rdb。</p><h5 id="RDB的优势"><a href="#RDB的优势" class="headerlink" title="RDB的优势"></a>RDB的优势</h5><ol><li><p>RDB 是一个非常紧凑（compact）的文件，它保存了 Redis<br>在某个时间点上的数据集。非常适合备份及灾难性恢复；</p></li><li><p>性能最大化，它唯一需要做的只是fork出子进程，避免执行IO操作；</p></li><li><p>相比于AOF机制，如果数据集很大，RDB的启动效率会更高。</p></li></ol><h5 id="RDB缺点"><a href="#RDB缺点" class="headerlink" title="RDB缺点"></a>RDB缺点</h5><ol><li><p>如果你想保证数据的高可用性，即最大限度的避免数据丢失，那么RDB将不是一个很好的选择。因为系统一旦在定时持久化之前出现宕机现象，此前没有来得及写入磁盘的数据都将丢失。</p></li><li><p>由于RDB是通过fork子进程来协助完成数据持久化工作的，因此，如果当数据集较大时，可能会导致整个服务器停止服务几百毫秒，甚至是1秒钟。</p></li></ol><h4 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h4><p>AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。</p><h5 id="AOF优点"><a href="#AOF优点" class="headerlink" title="AOF优点"></a>AOF优点</h5><ol><li><p>使用 AOF 持久化会让 Redis 变得非常耐久（much more durable）：Redis中提供了3中同步策略，即每秒同步（默认），每修改步和不同步。</p></li><li><p>由于该机制对日志文件的写入操作采用的是append模式，所以不需要seek，即使日志因为某些原因而包含了未写入完整的命令（比如写入时磁盘已满，写入中途停机，等等），redis-check-aof 工具也可以轻易地修复这种问题。</p></li><li><p>如果日志过大，Redis可以自动启用rewrite机制。即Redis以append模式不断的将修改数据写入到老的磁盘文件中，同时Redis还会创建一个新的文件用于记录此期间有哪些修改命令被执行。因此在进行rewrite切换时可以更好的保证数据安全性。</p></li><li><p>AOF包含一个格式清晰、易于理解的日志文件用于记录所有的修改操作。事实上，我们也可以通过该文件完成数据的重建。</p></li></ol><h5 id="AOF缺点"><a href="#AOF缺点" class="headerlink" title="AOF缺点"></a>AOF缺点</h5><ol><li><p>对于相同数量的数据集而言，AOF文件通常要大于RDB文件。RDB在恢复大数据集时的速度比 AOF 的恢复速度要快。</p></li><li><p>根据同步策略的不同，AOF在运行效率上往往会慢于RDB。</p></li></ol><h3 id="redis与memcached对比"><a href="#redis与memcached对比" class="headerlink" title="redis与memcached对比"></a>redis与memcached对比</h3><p>参考：<a href="https://www.imooc.com/article/23549" target="_blank" rel="noopener">https://www.imooc.com/article/23549</a></p><p>####二者定义</p><p>Memcached：一款完全开源、高性能的、分布式的内存系统；</p><p>Redis：一个开源的、Key-Value型、基于内存运行并支持持久化的NoSQL数据库；</p><h4 id="各方面对比"><a href="#各方面对比" class="headerlink" title="各方面对比"></a>各方面对比</h4><h5 id="网络IO之间的对比"><a href="#网络IO之间的对比" class="headerlink" title="网络IO之间的对比"></a>网络IO之间的对比</h5><p>Memcached是多线程，非阻塞IO复用的网络模型Redis使用单线程的IO复用模型，在高并发场景的压力下，多线程非阻塞式IO的Memcached表现会更加优异。</p><h5 id="内存管理机制"><a href="#内存管理机制" class="headerlink" title="内存管理机制"></a>内存管理机制</h5><ol><li><p>Redis内存空间的利用比Memcahced更精细，引入Memcached是用一个“盒子”对数据进行承载，哪怕这个盒子的尺寸再合适，也不可避免的会有空置；</p></li><li><p>Memcached完美的解决了内存碎片的问题；</p></li><li><p>Memcached内部还存在一个slot的机制，对内存的使用优先使用废弃内存，在内存的重复利用上也具有一定的优势；</p></li><li><p>Redis并不是将所有内存数据都存放在内存中，只会将所有的key存放在内存，在读取的时候会有一定几率存在一次IO操作，在这一点上，Redis是使用时间换取了空间的策略；</p></li></ol><h5 id="数据一致性保障"><a href="#数据一致性保障" class="headerlink" title="数据一致性保障"></a>数据一致性保障</h5><p>Redis提供了一个“事务”的概念，虽然这是一个假的事务，由于Redis是单进程操作，所以Redis的事务仅仅只是将一组操作按顺序进行操作，在这之间不会插入任何其他命令，从而保证数据的一致性，但是这种方式很容易造成操作阻塞。</p><p>Memcached提供了类似于乐观锁一样的cas操作，会快速的返回处理成功或失败，不会对其他数据操作产生影响。在这一点上，Memcached的速度要比Redis更快也更安全。</p><h5 id="二者选择策略"><a href="#二者选择策略" class="headerlink" title="二者选择策略"></a>二者选择策略</h5><p>使用Redis的String类型做的事，都可以用Memcached替换，以此换取更好的性能提升；除此以外，优先考虑Redis；</p><h3 id="Redis的回收策略"><a href="#Redis的回收策略" class="headerlink" title="Redis的回收策略"></a>Redis的回收策略</h3><p><strong>MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？</strong></p><p>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略。</p><p>redis提供6种数据淘汰策略：</p><p>voltile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</p><p>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</p><p>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</p><p>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</p><p>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</p><p>no-enviction（驱逐）：禁止驱逐数据</p>]]></content>
      
      <categories>
          
          <category> 中间件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/08/05/hello-world/"/>
      <url>/2018/08/05/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
